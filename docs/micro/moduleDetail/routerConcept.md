# 路由概念篇

当前篇幅为路由的概念介绍，包含了

* 一些封装思想
* 模块文件组成
* 基座应用和微应用的不同之处
* 各个功能所做的事情一览

篇幅较长，偏概念，适合想探究具体内容、学习路由封装的同事查看

请结合具体的源码食用

## 何为路由？

路由即通过匹配规则实现某种行为（页面切换）的过程；

每个应用本质都是单页面应用，和传统的前端开发不同，单页面应用通过监听 url 的变化，决定在页面中渲染哪个组件，通过处理 url，使得页面切换不再需要依赖后台，也就是我们所说的前端路由。

由于当前技术栈为 vue，路由使用的是 [Vue-Router4](https://router.vuejs.org/zh/)

前端开发者应该熟练掌握 vue-router 的使用，可以从以下切入：

* 注册
* 导航守卫
* 路由跳转、编程式导航

框架已经对 vue-rouetr 进行了封装

## 路由注册模式

在框架中，路由的注册分为两种：

* 前端控制路由（静态路由）
    > 使用场景：前端不想依赖后台，只是单独页面的开发，还未到联调工作；<br/>
    > 不适用：路由权限控制（要基于接口）、按钮权限控制

* 后台控制路由（动态路由）
    > 使用场景：线上、权限控制 <br/>
    > 不适用：后台网络不通，开发页面不方便

:::tip 注意

整个系统的权限控制，都是基于动态路由去做的，在进行上线部署、测试等工作时，一定要将路由模式改为动态路由模式

在打包生产时，框架已将路由模式使用为 后台控制路由，这个各位开发不用关心，需要关心的是开发模式下路由模式的切换

:::

## 路由配置与系统菜单

系统菜单会基于路由的配置自动生成，无论静态路由还是动态路由，框架内部抹平了差异，统一了数据结构

## 模块内容

文件划分

![路由模块](/images/realize/router-module.png)

```zsh
├── backEnd.ts # 动态路由处理核心
├── common # 公共路由配置文件夹
├── frontEnd.ts # 静态路由处理核心
├── index.ts # 路由实例
└── modules # 业务模块路由配置文件夹
```

:::tip

路由模块基座应用和微应用的文件目录组成都是一样的，但是内部的实现略有不同，后续会列出基座应用和微应用的区别

:::

### 内容详解

#### 入口

index.ts 文件是整个系统的 vue-router 实例的创建、配置、抛出等

接下来会从基座应用和微应用出发，详解两种框架路由入口所做的大致事情，**后续的模块**都将以这这种方式进行对比

##### 基座应用

1. 实例创建
    - 1. 以 common 路由配置模块为入口，添加路由；
    - 2. 以 hash 模式创建路由；

2. 添加路由前置钩子

    - 1. 启动 NProgress 加载进度条
    - 2. 设置页面标题
    - 3. 提交路由加载状态为开始（用于页面加载 loading 标识）
    - 4. 判断是否为业务路由
    - 5. 判断登录过期
    - 6. 依据路由模式加载路由配置，动态需要请求接口数据等，跳转到 backEnd.ts 内
    - 7. 对 iframe、login、微应用等路由特殊处理，重定向等

3. 添加路由后置钩子

    - 1. 结束 NProgress 的加载
    - 2. 提交路由加载状态为结束
    - 3. 判断是否是登录后（首次登录或重新登录），提交首次登录状态

4. 抛出 router 实例

##### 微应用

1. 实例创建
    - 1. 以 common 路由配置模块为入口，添加路由；
    - 2. 以 hash 模式创建路由；

2. 添加路由前置钩子

    - 1. 启动 NProgress 加载进度条
    - 2. 设置页面标题（父子应用公用一个 html，对于标题的设置，无论是基座应用修改，还是微应用修改，后加载的优先级更高）
    - 3. 提交路由加载状态为开始（微应用自己的加载状态，考虑去掉）
    - 4. 判断是否为动态路由的同时，判断应用功能树中是否包含当前系统的节点（依据 package.json 中的 name 配置），如果没有，则 return 后续判断
    - 5. 判断路由模式，加载对应的路由文件，动态添加路由
    - 6. 动态添加完路由后，重定到目标路由

3. 添加路由后置钩子

    - 1. 结束 NProgress 的加载
    - 2. 提交路由加载状态为结束

4. 抛出 router 实例

:::tip

在加载微应用之前，基座应用的路由钩子是一定会被触发的（微应用资源的加载与解析一定是依据基座应用的路由匹配程度来完成的），所以，对于登录鉴权的配置，只需要在基座应用进行就可以了

当登录失效时，路由根本不会跳转到微应用的匹配路径，而微应用只需要关心自己的业务路由的注册及跳转就可以了

得出分工：

* 基座应用基础设施路由配置、路由鉴权、页面加载状态
* 微应用，加载并注册对应模式的业务路由

:::

#### 静态路由处理核心

前文已知框架的路由注册分为静态路由与动态路由，静态路由的注册处理主要由 `/src/router/frontEnd.ts` 完成

:::tip

纵观框架下来，你会发现每个核心模块下都添加了 `modules` 文件夹的区分，在使用过程中，你会发现你只需要编写配置对应的模块，而不需要其他的处理，如引用、注册

是因为各个大模块下，都采用了**自动化引用**的一个概念，把引用、注册的脏活累活，都交给了框架统一处理

自动化引用，都是基于 [require.context](https://www.jianshu.com/p/c894ea00dfec) 这个 api 来完成的

请记住 <strong style="color: #ff3040; ">自动化</strong> 的概念，这属于前端工程化的一部分

:::

##### 基座应用

由于基座应用需要对应用菜单负责，在处理静态路由的同时，需要抛出基础的路由树形结构

1. 依据路由模式，决定抛出的数组，如果是后台控制路由，则为空
2. 自动化引入 `./modules/xxx.ts` 模块
3. 判断是否为微应用的静态路由（是否是 `./modules/microApps/` 目录下的文件），如果是，在微应用路由静态配置对象的基础之上，添加微应用的前缀（因为微应用的配置是不包含自己应用名称的，为了便捷复制，路由添加应用前缀的工作交给了自动化处理工具）
    > 一是需要判断是否在 `microApps` 目录下；<br/>
    > 二是要判断对应的微应用是否已经注册；<br/>
    > 微应用前缀是用来匹配微应用路由以加载目标资源的

4. 基于基座应用的配置数组+微应用的配置数组，做两件事情
    - 1. 保持树形结构，提交全局状态管理，作为应用功能菜单的数据源
    - 2. 树形结构拉平，形成一维注册路由数组返回（会由 `./common/index.ts` 引用）

5. 抛出注册数组

##### 微应用

微应用不同于基座应用，微应用不需要维护菜单数据，也就是不需要维护树形结构

1. 自动化引入 `./modules/` 下的模块
2. 为每个路由节点添加基座应用传递的基础路由（基座应用传递的是应用名称，嵌套应用传递的是当前路由）
3. 经过方法处理成一维数组
    > 这里会有一个特殊处理：如果路由是标识模糊匹配的，则需要添加 `xxx/:page*` 来适应模糊匹配，常用于嵌套应用的配置

4. 抛出注册数组

:::tip

无论是静态路由还是动态路由，微应用都只是单纯的业务路由模块注册，没有嵌套（除了父级应用传递的基础路径），直接运行在 根 `router-view` 中的

在基座应用中体现到业务展示区域（中心区域）

:::

#### 动态路由处理核心

文件： `/src/router/backEnd.ts`

##### 基座应用

动态路由的处理，基于后台返回（异步，内部会采用 await 阻塞路由的跳转）的当前用户的权限应用功能树，在系统进行修改应用功能树时，会自动重新加载，以适应新的改变

其中的实时改变包括

* 菜单信息
* 路由配置
* 路由元信息

1. 核心为 async 函数，内部 await 阻塞
2. 监听当前登录用户的菜单全局状态树（结果处理）
    > 通过监听全局状态的变化，重新执行路由的处理、添加等

3. 阻塞性请求后台数据，在响应完成后，提交全局状态：当前用户的应用功能树
4. 递归处理功能树
    > 保持树形结构，作为应用功能菜单的数据源
    > 树形结构拉平，获得一维注册路由数组，数组遍历使用 `router.addRoute` 添加到布局路由组件中

5. 提交二者
6. 执行完成，返回继续导航

##### 微应用

微应用动态路由的配置数组，是经由基座应用处理过的，其中包括

* path 的处理
* 组件的引用处理
* 路由元信息的装填
* 错误组件的添加

换句话说，微应用的动态路由是同步的，不需要再请求数据，微应用只需要对父级应用传递的数据进行筛选注册即可

1. 筛选以当前系统名称（package.json 下的 name）开头的路由配置对象
2. 二次处理路径（基于路由的元数据 `componentPath`），某些情况下，需要将当前应用的名称替换为父级应用传递的[基础路由](https://micro-zoe.github.io/micro-app/docs.html#/zh-cn/env?id=__micro_app_base_route__)（基座应用传递的适用应用名称，嵌套应用的则不适用，所以需要替换）
    > 这里会有一个特殊处理：如果路由是标识模糊匹配的，则需要添加 `xxx/:page*` 来适应模糊匹配，常用于嵌套应用的配置

3. 基于元数据 `componentPath`，进行当前系统的组件装填（别名应用、views 文件夹等），及加载错误组件的装填
4. 将二次处理的整个路由配置，添加到当前微应用的路由实例中
5. 将处理的注册路由数组，提交到全局（微应用）状态树中，微应用的注册数组未体现实际使用价值

#### 公共路由文件夹

##### 基座应用

common 文件夹有两个作用

* 存放公共路由模块
* 引入静态路由

目前基座应用的公共路由模块内容如下：

```zsh
├── index.ts
├── microAppBaseRoute.ts
└── my.ts
```

1. index.ts 是公共路由的入口，内部应用静态路由
2. microAppBaseRoute 是使用静态路由的方式添加已注册微应用的保险路由的路由数组（所谓的保险数组是指以微应用的注册名称开头，确保每个以微应用名称开头的路由都能匹配到微应用路由根组件）
3. my.ts 是系统的个人设置模块的路由，属于公共路由的模块划分

##### 微应用

内容如下

```zsh
├── blurry.ts
├── exposes.ts
├── index.ts
└── utils.ts
```

1. index.js 包含公共路由的注册、父级应用[基础路由](https://micro-zoe.github.io/micro-app/docs.html#/zh-cn/env?id=__micro_app_base_route__) 的添加
2. exposes 作为向外提供的组件的静态路由配置（详见嵌套应用的使用）
    > 由于一个应用作为生产者向外提供的内容是确定性的，所以，仅需将生产物以静态路由的方式注册即可<br/>
    > 由于路由是确定的，我们也不需要通过路由元信息自动处理模糊匹配，我们只需要在注册路由时，明确注册为模糊匹配即可

3. blurry 其他一些模糊匹配的路由，暂无实际体现，预留配置文件
4. utils.ts 处理工具文件

:::tip

作为微应用的公共静态路由模块，也是需要添加父级传递的基础路径的，由于没有经过 `frontEnd.ts` 的处理，需要自己做一层特殊处理

:::

#### 业务路由模块

`/src/router/modules` 文件夹用来存放静态业务路由的模块

模块内容，基座应用和微应用的内容一致

区别在于，由于静态路由文件是物理磁盘上的存储概念，基座应用并不能便捷的拿到微应用的静态路由，所以需要复制粘贴微应用的静态路由到基座应用的模块下

需要放到 `/src/router/modules/microApps/` 再以微应用名称划分文件目录

:::tip

这里的微应用名称目录是至关重要的，基座应用的静态路由处理核心会把这个目录名称作为路由的匹配前缀进行拼接

:::

## 路由信息配置对象

:::tip

整个路由配置的方式，都是基于路由配置对象去完成的，后台动态路由同样是将数据结构转换成（抹平差异）路由配置对象；

说直白些，路由就是对于路由配置对象的堆砌；

路由配置对象，也限制了接口，接口位于 `/src/@types/Route.ts`

文件抛出了一个默认的配置对象的类型，并抛出了路由元信息（meta）的类型

开发人员应该熟练掌握路由配置对象的属性，理解了路由配置对象，才能灵活的配置路由

:::

### 配置对象

```ts
interface RouteConfig {
    path: _RouteRecordBase['path']
    meta: RouteMeta
    name?: _RouteRecordBase['name']
    component?: RouteComponent | Lazy<RouteComponent>
    children?: RouteConfig[]
    redirect?: _RouteRecordBase['redirect']
    alias?: _RouteRecordBase['alias']
    props?: RouteRecordNormalized['props']
    beforeEnter?: _RouteRecordBase['beforeEnter']
}
```

* path
    > 唯一标识，必须

* meta
    > 路由元信息，包含一些当前路由的处理信息，如：标题，是否隐藏等等

* name
    > 路由名称，可以理解为访问当前路由的一个简写，因为 path 可能会很长，要保证 name 全局唯一，否则会抛出警告

* component
    > 路由要加载的组件，同步引用，或懒加载

* children
    > 子路由，框架采用较严格的父子结构，父子结构会适用于系统菜单的生成，内部会处理成一维数组注册

* redirect 
    > [重定向](https://router.vuejs.org/zh/guide/essentials/redirect-and-alias.html)

* alias
    > [别名](https://router.vuejs.org/zh/guide/essentials/redirect-and-alias.html)

* props
    > [将 props 传递给路由组件](https://router.vuejs.org/zh/guide/essentials/passing-props.html)

* beforeEnter
    > [单路由导航守卫](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html)

### 路由元信息

一些路由的附加信息都是以 meta 的方式进行携带的，各字段含义如下

```ts
interface RouteMeta {
    /**
     * 菜单栏及 tagsView 栏、菜单搜索名称（国际化）
     */
    title: string
    /**
     * 是否超链接菜单，开启外链条件，`1、isLink:true 2、链接地址不为空`
     */
    isLink?: string
    /**
     * 是否隐藏此路由
     */
    hidden?: boolean
    /**
     * 是否缓存组件状态
     */
    isCache?: boolean
    /**
     * 是否固定在 tagsView 栏上
     */
    isAffix?: boolean
    /**
     * 是否内嵌窗口，，开启条件，`1、isIframe:true 2、链接地址不为空`
     */
    openMode?: OpenMode
    /**
     * 图标
     */
    icon?: string
    /**
     * 功能类型，和后台对应
     */
    type?: FuncType
    /**
     * 是否包含按钮功能信息，和后台对应
     */
    btns?: AppFunc[]
    /**
     * 路由层级（菜单）
     */
    grade?: number
    /**
     * iframe 内嵌外部链接地址
     */
    link?: string
    /**
     * 应用功能 id === 路由 id
     * 在后台控制路由时，路由在注册时会被赋予应用功能的 id 作为唯一标识
     * 在配置前台路由时，应尽量与后台应用功能表中的节点 id 对应
     */
    funcId?: string
    /**
     * 路由组件路径
     */
    componentPath?: string
    /**
     * 是否模糊匹配
     */
    isBlurry?: boolean
    /**
     * 预留字段
     */
    [k: string]: any
}
```
